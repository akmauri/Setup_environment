# Ralph Process - Progress and Learnings

This file stores learnings, patterns, and context discovered during Ralph iterations.
It is append-only - never overwrite, only add new entries.

Each entry should include:
- Timestamp
- Story ID and title
- Key learnings
- Patterns discovered
- Gotchas to avoid
- Useful context for future iterations

---

[2026-01-15 12:00:00] Story 1.1: Project Setup & Repository Structure

Learnings:
- Monorepo structure already exists with apps/web, apps/api, packages/shared, packages/ui, packages/config, packages/db
- TypeScript strict mode is enabled in root and all packages
- ESLint and Prettier are configured with shared rules
- Husky pre-commit hooks are configured and working
- CI/CD pipeline exists in .github/workflows/ci.yml
- Docker Compose was missing n8n and ComfyUI services - added them
- README needed architecture overview and development guidelines - enhanced it

Patterns:
- TypeScript path aliases require baseUrl to be set in tsconfig.json for proper resolution
- Next.js apps need @/* path alias configured in tsconfig.json with baseUrl
- Docker Compose services should include all required services (PostgreSQL, Redis, n8n, ComfyUI)

Gotchas:
- Pre-existing code in apps/api has linting errors (empty catch blocks, console statements, test files not in tsconfig)
- These are pre-existing issues and should be addressed in a separate code quality story
- ESLint configuration for API package needs to exclude test files or include them in tsconfig

Useful Context:
- Project uses Turborepo for monorepo management
- All packages extend root tsconfig.json for consistent TypeScript configuration
- Pre-commit hooks run: lint, format:check, type-check
- CI/CD pipeline runs: lint, format:check, type-check, test, build
- Docker Compose services: postgres (5432), redis (6379), n8n (5678), comfyui (8188)

---

[2026-01-15 13:00:00] Story 1.2: Multi-Tenant Database Architecture

Learnings:
- Prisma is used for migrations and ORM, but tenant schemas require raw SQL for dynamic schema creation
- Schema-per-tenant architecture uses PostgreSQL search_path to route queries to correct tenant schema
- Tenant schema names follow pattern: tenant_{uuid_with_underscores}
- All tenant-specific tables (users, content, social_accounts, workflows, publish_jobs, analytics, teams, comments, notifications) are created in tenant schemas
- Public schema contains system-wide tables: tenants, migrations, countries, timezones, platforms
- PgBouncer connection pooling is configured in docker-compose for production-ready setup
- Database middleware (tenantDbMiddleware) extracts tenant_id from JWT token and sets search_path automatically

Patterns:
- Tenant schema creation: CREATE SCHEMA tenant_{id}, then apply migrations
- Tenant schema deletion: DROP SCHEMA CASCADE for GDPR compliance
- Database connection uses search_path to route queries: SET search_path TO tenant_{id}, public
- All tenant tables have updated_at triggers using shared function update_updated_at_column()
- Foreign keys in tenant schemas reference tables within the same schema (no cross-schema FKs)

Gotchas:
- Prisma doesn't natively support dynamic schemas - use raw SQL for tenant schema operations
- Schema names must be sanitized (replace hyphens with underscores) for PostgreSQL compatibility
- Tenant schema migrations must be applied after schema creation, not via Prisma migrate
- search_path must be set per connection/transaction, not globally
- PgBouncer uses transaction pooling mode for best compatibility with search_path

Useful Context:
- Database connection string: Use DATABASE_URL for primary, DATABASE_READ_URL for read replicas
- PgBouncer port: 6432 (default), PostgreSQL direct: 5432
- Backup strategy documented in docs/DATABASE_BACKUP_STRATEGY.md
- Read replica configuration documented in docs/DATABASE_READ_REPLICA.md
- Migration rollback procedures documented in packages/db/docs/MIGRATION_ROLLBACK.md
- Tenant service functions: createTenant, createTenantSchema, deleteTenantSchema, applyTenantSchemaMigration

---

[2026-01-15 14:00:00] Story 1.3: User Authentication System

Learnings:
- Comprehensive authentication system implemented with email/password and OAuth (Google, Microsoft, Okta)
- Password hashing uses bcrypt with configurable salt rounds (minimum 10, default 10)
- JWT tokens use separate secrets for access (JWT_SECRET) and refresh (JWT_REFRESH_SECRET) tokens
- Access tokens expire in 15 minutes, refresh tokens expire in 30 days
- Token rotation implemented: refresh tokens are single-use, old session deleted when new pair is issued
- Email verification tokens expire in 24 hours, password reset tokens expire in 1 hour
- Rate limiting implemented: 5 attempts per 15 minutes for auth endpoints, 100 requests per 15 minutes for general endpoints
- 2FA (TOTP) implemented using speakeasy library with QR code generation
- Session management tracks device info (user agent, IP address) and last activity
- All database queries use parameterized queries (Prisma.sql) to prevent SQL injection
- OAuth user creation automatically creates default tenant if user doesn't have one

Patterns:
- Authentication routes organized in apps/api/src/routes/auth.routes.ts
- Services separated by concern: auth.service.ts, jwt.service.ts, password.service.ts, token.service.ts, oauth.service.ts, totp.service.ts, session.service.ts, email.service.ts
- OAuth config centralized in apps/api/src/config/oauth.config.ts
- Rate limiting middleware uses in-memory store (should use Redis in production)
- Token hashing uses SHA-256 for secure storage
- All auth endpoints use createAuthRateLimitMiddleware() for stricter rate limiting
- Session table created dynamically per tenant schema using ensureSessionsTable()

Gotchas:
- Duplicate imports cause TypeScript errors - always check for duplicate import statements
- hashToken function was imported multiple times in session.service.ts (fixed)
- OAuth tokens should be stored encrypted in production (currently TODO in user.service.ts)
- Rate limiting uses in-memory store which won't work across multiple server instances - need Redis for production
- Tenant resolution for OAuth users uses simplified email domain lookup - should use proper user-tenant association table in production

Useful Context:
- JWT_SECRET and JWT_REFRESH_SECRET must be set in environment variables
- BCRYPT_SALT_ROUNDS defaults to 10 if not set (minimum enforced)
- OAuth providers require client ID and secret in environment: GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, etc.
- Email service requires SMTP configuration (SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS)
- All auth routes mounted at /api/v1/auth
- OAuth callback routes: /api/v1/auth/callback/:provider (google, microsoft, okta)
- Refresh token endpoint: POST /api/v1/auth/refresh
- Logout endpoint: POST /api/v1/auth/logout
- 2FA endpoints: POST /api/v1/auth/2fa/enable, POST /api/v1/auth/2fa/verify, POST /api/v1/auth/2fa/disable

---

[2026-01-15 15:00:00] Story 1.4: Basic User Management

Learnings:
- User profile management implemented with timezone and preferences support
- Email change flow requires verification of new email address (24-hour token expiry)
- Account deletion implements soft delete with 30-day retention period for GDPR compliance
- Activity logging tracks all profile changes with timestamp, IP address, and user agent
- User data export provides complete JSON export for GDPR compliance
- Profile endpoint returns subscription tier from tenant record
- Preferences stored as JSONB in database for flexible schema
- Migration function added to update existing user tables with new columns (timezone, preferences, email change fields, deleted_at)
- Activity logs table created per tenant schema to track user actions

Patterns:
- Profile updates log changes to activity_logs table before applying updates
- Soft delete pattern: set deleted_at timestamp instead of hard delete
- Email change uses same verification token pattern as email verification
- User preferences use JSONB for flexible schema (notifications, theme, language, date format)
- All user queries filter by deleted_at IS NULL to exclude soft-deleted accounts
- Subscription tier retrieved from tenant record, not stored in user table

Gotchas:
- Prisma.sql template literals require Prisma.raw() for SQL expressions like type casts (::uuid, ::jsonb, ::timestamp)
- JSON.stringify() must be called before using in Prisma.raw() to avoid template literal issues
- Activity logs table created dynamically per tenant using ensureActivityLogsTable()
- Email change verification requires separate endpoint (not same as initial email verification)
- Account deletion requires password confirmation even for OAuth users (if password_hash exists)

Pending Features:
- Avatar file upload with image validation (max 5MB, JPG/PNG/WebP) - requires multipart/form-data handling
- S3-compatible storage integration for avatar uploads - requires AWS SDK or MinIO setup
- Note: Profile currently accepts avatar URLs via PUT /api/v1/user/profile. File upload can be added when S3 storage is configured.

Useful Context:
- User profile endpoint: GET /api/v1/user/profile
- Update profile endpoint: PUT /api/v1/user/profile (supports name, picture URL, timezone, preferences)
- Email change request: POST /api/v1/user/change-email
- Email change verification: POST /api/v1/user/verify-email-change
- Account deletion: DELETE /api/v1/user/account (requires password in body)
- Data export: GET /api/v1/user/export (returns JSON file download)
- Activity logs stored in activity_logs table per tenant schema
- User preferences structure: { notifications: { email, push, inApp }, theme, language, dateFormat }
- Migration function migrateUsersTable() safely adds new columns to existing user tables

---
